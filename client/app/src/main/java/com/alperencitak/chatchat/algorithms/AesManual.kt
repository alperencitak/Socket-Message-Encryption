package com.alperencitak.chatchat.algorithms

import android.util.Base64

class AesManual(
    private val keyBytes: ByteArray
) : Algorithm {

    init {
        require(keyBytes.size == 16) { "AES-128 için anahtar 16 byte olmalı" }
    }

    private val blockSize = 16
    private val Nb = 4
    private val Nk = 4
    private val Nr = 10

    // S-box
    private val sBox = intArrayOf(
        0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
        0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
        0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
        0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
        0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
        0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
        0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
        0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
        0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
        0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
        0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
        0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
        0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
        0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
        0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
        0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
    )

    private val invSBox = intArrayOf(
        0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,
        0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,
        0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,
        0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,
        0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,
        0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,
        0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,
        0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,
        0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,
        0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,
        0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,
        0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,
        0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,
        0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,
        0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,
        0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D
    )

    private val rCon = longArrayOf(
        0x00000000L,
        0x01000000L,0x02000000L,0x04000000L,0x08000000L,
        0x10000000L,0x20000000L,0x40000000L,0x80000000L,
        0x1b000000L,0x36000000L
    )

    private fun xtime(a: Int): Int {
        return ((a shl 1) xor (if (a and 0x80 != 0) 0x1B else 0x00)) and 0xFF
    }

    private fun mul(a: Int, b: Int): Int {
        var aa = a and 0xFF
        var bb = b and 0xFF
        var res = 0
        var tempB = bb
        var tempA = aa
        while (tempB > 0) {
            if (tempB and 1 != 0) res = res xor tempA
            tempA = xtime(tempA)
            tempB = tempB shr 1
        }
        return res and 0xFF
    }

    private fun expandKey(key: ByteArray): IntArray {
        val totalBytes = Nb * (Nr + 1) * 4 // 4 * (Nr+1) * 4 = 176
        val w = IntArray(totalBytes)
        for (i in 0 until 16) w[i] = key[i].toInt() and 0xFF

        var bytesGenerated = 16
        var rconIteration = 1
        val temp = IntArray(4)

        while (bytesGenerated < totalBytes) {
            for (i in 0..3) temp[i] = w[bytesGenerated - 4 + i]

            if (bytesGenerated % 16 == 0) {
                val t = temp[0]
                temp[0] = temp[1]
                temp[1] = temp[2]
                temp[2] = temp[3]
                temp[3] = t

                for (i in 0..3) temp[i] = sBox[temp[i]]
                temp[0] = temp[0] xor (((rCon[rconIteration] ushr 24) and 0xFF).toInt())
                rconIteration++
            }

            for (i in 0..3) {
                w[bytesGenerated] = (w[bytesGenerated - 16] xor temp[i]) and 0xFF
                bytesGenerated++
            }
        }
        return w
    }

    private fun subBytes(state: IntArray) {
        for (i in state.indices) state[i] = sBox[state[i]] and 0xFF
    }

    private fun invSubBytes(state: IntArray) {
        for (i in state.indices) state[i] = invSBox[state[i]] and 0xFF
    }

    private fun shiftRows(state: IntArray) {
        val tmp = IntArray(16)
        for (r in 0..3) {
            for (c in 0..3) {
                tmp[r + 4 * c] = state[r + 4 * ((c + r) % 4)]
            }
        }
        for (i in 0..15) state[i] = tmp[i]
    }

    private fun invShiftRows(state: IntArray) {
        val tmp = IntArray(16)
        for (r in 0..3) {
            for (c in 0..3) {
                tmp[r + 4 * c] = state[r + 4 * ((c - r + 4) % 4)]
            }
        }
        for (i in 0..15) state[i] = tmp[i]
    }

    private fun mixColumns(state: IntArray) {
        for (c in 0..3) {
            val col = IntArray(4)
            for (r in 0..3) col[r] = state[r + 4 * c]
            val a0 = (mul(0x02, col[0]) xor mul(0x03, col[1]) xor col[2] xor col[3]) and 0xFF
            val a1 = (col[0] xor mul(0x02, col[1]) xor mul(0x03, col[2]) xor col[3]) and 0xFF
            val a2 = (col[0] xor col[1] xor mul(0x02, col[2]) xor mul(0x03, col[3])) and 0xFF
            val a3 = (mul(0x03, col[0]) xor col[1] xor col[2] xor mul(0x02, col[3])) and 0xFF
            state[0 + 4 * c] = a0
            state[1 + 4 * c] = a1
            state[2 + 4 * c] = a2
            state[3 + 4 * c] = a3
        }
    }

    private fun invMixColumns(state: IntArray) {
        for (c in 0..3) {
            val col = IntArray(4)
            for (r in 0..3) col[r] = state[r + 4 * c]
            val a0 = (mul(0x0e, col[0]) xor mul(0x0b, col[1]) xor mul(0x0d, col[2]) xor mul(0x09, col[3])) and 0xFF
            val a1 = (mul(0x09, col[0]) xor mul(0x0e, col[1]) xor mul(0x0b, col[2]) xor mul(0x0d, col[3])) and 0xFF
            val a2 = (mul(0x0d, col[0]) xor mul(0x09, col[1]) xor mul(0x0e, col[2]) xor mul(0x0b, col[3])) and 0xFF
            val a3 = (mul(0x0b, col[0]) xor mul(0x0d, col[1]) xor mul(0x09, col[2]) xor mul(0x0e, col[3])) and 0xFF
            state[0 + 4 * c] = a0
            state[1 + 4 * c] = a1
            state[2 + 4 * c] = a2
            state[3 + 4 * c] = a3
        }
    }

    private fun addRoundKey(state: IntArray, roundKey: IntArray) {
        for (i in 0 until 16) {
            state[i] = state[i] xor (roundKey[i] and 0xFF)
        }
    }

    private fun getRoundKey(expandedKey: IntArray, round: Int): IntArray {
        val rk = IntArray(16)
        val start = round * 16
        for (i in 0 until 16) rk[i] = expandedKey[start + i]
        return rk
    }

    private fun pkcs7Pad(data: ByteArray): ByteArray {
        var padLen = blockSize - (data.size % blockSize)
        if (padLen == 0) padLen = blockSize
        val out = ByteArray(data.size + padLen)
        System.arraycopy(data, 0, out, 0, data.size)
        for (i in data.size until out.size) out[i] = padLen.toByte()
        return out
    }

    private fun pkcs7Unpad(data: ByteArray): ByteArray {
        require(data.isNotEmpty() && data.size % blockSize == 0)
        val pad = data.last().toInt() and 0xFF
        require(pad in 1..blockSize)
        val newLen = data.size - pad
        require(newLen >= 0)
        return data.copyOfRange(0, newLen)
    }

    // Tek blok şifreleme
    private fun encryptBlock(input: ByteArray, expandedKey: IntArray): ByteArray {
        val state = IntArray(16)
        for (i in 0 until 16) state[i] = input[i].toInt() and 0xFF

        addRoundKey(state, getRoundKey(expandedKey, 0))

        for (round in 1 until Nr) {
            subBytes(state)
            shiftRows(state)
            mixColumns(state)
            addRoundKey(state, getRoundKey(expandedKey, round))
        }

        subBytes(state)
        shiftRows(state)
        addRoundKey(state, getRoundKey(expandedKey, Nr))

        val out = ByteArray(16)
        for (i in 0 until 16) out[i] = (state[i] and 0xFF).toByte()
        return out
    }

    private fun decryptBlock(input: ByteArray, expandedKey: IntArray): ByteArray {
        val state = IntArray(16)
        for (i in 0 until 16) state[i] = input[i].toInt() and 0xFF

        addRoundKey(state, getRoundKey(expandedKey, Nr))
        for (round in Nr - 1 downTo 1) {
            invShiftRows(state)
            invSubBytes(state)
            addRoundKey(state, getRoundKey(expandedKey, round))
            invMixColumns(state)
        }
        invShiftRows(state)
        invSubBytes(state)
        addRoundKey(state, getRoundKey(expandedKey, 0))

        val out = ByteArray(16)
        for (i in 0 until 16) out[i] = (state[i] and 0xFF).toByte()
        return out
    }

    // encrypt / decrypt
    override fun encrypt(text: String, shift: Int): String {
        val plain = text.toByteArray(Charsets.UTF_8)
        val padded = pkcs7Pad(plain)
        val expandedKey = expandKey(keyBytes)

        val cipherBytes = ByteArray(padded.size)
        var offset = 0
        while (offset < padded.size) {
            val block = padded.copyOfRange(offset, offset + 16)
            val enc = encryptBlock(block, expandedKey)
            System.arraycopy(enc, 0, cipherBytes, offset, 16)
            offset += 16
        }

        return Base64.encodeToString(cipherBytes, Base64.NO_WRAP)
    }

    override fun decrypt(text: String, shift: Int): String {
        val cipher = Base64.decode(text, Base64.NO_WRAP)
        require(cipher.size % 16 == 0) { "Şifreli veri 16 byte blok uzunluğunda olmalı" }
        val expandedKey = expandKey(keyBytes)

        val out = ByteArray(cipher.size)
        var offset = 0
        while (offset < cipher.size) {
            val block = cipher.copyOfRange(offset, offset + 16)
            val dec = decryptBlock(block, expandedKey)
            System.arraycopy(dec, 0, out, offset, 16)
            offset += 16
        }

        val unpadded = pkcs7Unpad(out)
        return String(unpadded, Charsets.UTF_8)
    }
}
